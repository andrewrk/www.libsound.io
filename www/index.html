<html>
  <head>
    <title>libsoundio: cross-platform audio input and output</title>
    <link href="style.css" rel="stylesheet" type="text/css">
    <link href="github-gist.css" rel="stylesheet" type="text/css">
    <link href='http://fonts.googleapis.com/css?family=Lato:300,400|Open+Sans:300|Ubuntu+Mono:400' rel='stylesheet' type='text/css'>
  </head>
  <body>
    <div class="navigation">
      <nav class="container">
        <div class="logo">libsoundio</div>
        <ul class="nav-links">
          <li><a href="#releases">Download</a></li>
          <li><a href="/doc">Documentation</a></li>
          <li><a href="https://github.com/andrewrk/libsoundio">Source Code</a></li>
          <li><a href="https://github.com/andrewrk/libsoundio/issues">Issue Tracker</a></li>
          <li><a href="https://salt.bountysource.com/teams/gdaw">Support This Project</a></li>
        </ul>
      </nav>
    </div>

    <div class="hero-area">
      <div class="valign-parent">
        <div class="valign-child">
         <h1>cross-platform audio input and output</h1>
         <h2>for real-time &amp; consumer software</h2>
        </div>
      </div>
    </div>

    <div class="highlight">
      <p>
      libsoundio is a lightweight abstraction over various sound drivers. It provides a
      well-documented API that operates consistently regardless of the sound driver it
      connects to. It performs no buffering or processing on your behalf; instead exposing
      the raw power of the underlying backend.
      </p>
      <p>
      libsoundio is appropriate for games, music players, digital audio workstations,
      and various utilities.
      </p>
      <p>
      libsoundio is serious about robustness. It even handles
      <a href="https://github.com/andrewrk/malcheck">out of memory conditions</a>
      correctly.
      </p>
      <h2>Features &amp; Limitations</h2>
      <div class="features-limitations">
        <ul>
          <li>Supported backends:
            <ul>
              <li><a href="http://jackaudio.org/">JACK</a></li>
              <li><a href="http://www.freedesktop.org/wiki/Software/PulseAudio/">PulseAudio</a></li>
              <li><a href="http://www.alsa-project.org/">ALSA</a></li>
              <li><a href="https://developer.apple.com/library/mac/documentation/MusicAudio/Conceptual/CoreAudioOverview/Introduction/Introduction.html">CoreAudio</a></li>
              <li> <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dd371455%28v=vs.85%29.aspx">WASAPI</a></li>
              <li>Dummy (silence)</li>
            </ul>
          </li>
          <li>
          Exposes both raw devices and shared devices. Raw devices give you the best
          performance but prevent other applications from using them. Shared devices
          are default and usually provide sample rate conversion and format
          conversion.
          </li>
          <li>
          Exposes both device id and friendly name. id you could save in a config file
          because it persists between devices becoming plugged and unplugged, while
          friendly name is suitable for exposing to users.
          </li>
          <li>Supports optimal usage of each supported backend. The same API does the right thing whether the backend has a fixed buffer size, such as on JACK and CoreAudio, or whether it allows directly managing the buffer, such as on ALSA or PulseAudio.</li>
          <li>C library. Depends only on the respective backend API libraries and libc. Does not depend on libstdc++, and does not have exceptions, run-time type information, or <a href="http://latentcontent.net/2007/12/05/libpng-worst-api-ever/">setjmp</a>.</li>
          <li>Errors are communicated via return codes, not logging to stdio.</li>
          <li>Supports channel layouts (also known as channel maps), important for surround sound applications.</li>
          <li>Ability to monitor devices and get an event when available devices change.</li>
          <li>Ability to get an event when the backend is disconnected, for example when the JACK server or PulseAudio server shuts down.</li>
          <li>Detects which input device is default and which output device is default.</li>
          <li>Ability to connect to multiple backends at once. For example you could have an ALSA device open and a JACK device open at the same time.</li>
          <li>Meticulously checks all return codes and memory allocations and uses meaningful error codes.</li>
          <li>
            Compare libsoundio to:
            <a href="https://github.com/andrewrk/libsoundio/wiki/libsoundio-vs-PortAudio">PortAudio</a>,
            <a href="https://github.com/andrewrk/libsoundio/wiki/libsoundio-vs-RtAudio">RtAudio</a>,
            or <a href="https://github.com/andrewrk/libsoundio/wiki/libsoundio-vs-SDL2">SDL2</a>.
          </li>
          <li>
            MIT licensed.
          </li>
        </ul>
      </div>
      <h2>Basic Sine Wave Example</h2>
<pre><code>#include &lt;soundio/soundio.h&gt;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;

static const float PI = 3.1415926535f;
static float seconds_offset = 0.0f;
static void write_callback(struct SoundIoOutStream *outstream,
        int frame_count_min, int frame_count_max)
{
    const struct SoundIoChannelLayout *layout = &amp;outstream-&gt;layout;
    float float_sample_rate = outstream-&gt;sample_rate;
    float seconds_per_frame = 1.0f / float_sample_rate;
    struct SoundIoChannelArea *areas;
    int frames_left = frame_count_max;
    int err;

    while (frames_left &gt; 0) {
        int frame_count = frames_left;

        if ((err = soundio_outstream_begin_write(outstream, &amp;areas, &amp;frame_count))) {
            fprintf(stderr, "%s\n", soundio_strerror(err));
            exit(1);
        }

        if (!frame_count)
            break;

        float pitch = 440.0f;
        float radians_per_second = pitch * 2.0f * PI;
        for (int frame = 0; frame &lt; frame_count; frame += 1) {
            float sample = sinf((seconds_offset + frame * seconds_per_frame) * radians_per_second);
            for (int channel = 0; channel &lt; layout-&gt;channel_count; channel += 1) {
                float *ptr = (float*)(areas[channel].ptr + areas[channel].step * frame);
                *ptr = sample;
            }
        }
        seconds_offset += seconds_per_frame * frame_count;

        if ((err = soundio_outstream_end_write(outstream))) {
            fprintf(stderr, "%s\n", soundio_strerror(err));
            exit(1);
        }

        frames_left -= frame_count;
    }
}

int main(int argc, char **argv) {
    int err;
    struct SoundIo *soundio = soundio_create();
    if (!soundio) {
        fprintf(stderr, "out of memory\n");
        return 1;
    }

    if ((err = soundio_connect(soundio))) {
        fprintf(stderr, "error connecting: %s", soundio_strerror(err));
        return 1;
    }

    soundio_flush_events(soundio);

    int default_out_device_index = soundio_default_output_device_index(soundio);
    if (default_out_device_index &lt; 0) {
        fprintf(stderr, "no output device found");
        return 1;
    }

    struct SoundIoDevice *device = soundio_get_output_device(soundio, default_out_device_index);
    if (!device) {
        fprintf(stderr, "out of memory");
        return 1;
    }

    fprintf(stderr, "Output device: %s\n", device-&gt;name);

    struct SoundIoOutStream *outstream = soundio_outstream_create(device);
    outstream-&gt;format = SoundIoFormatFloat32NE;
    outstream-&gt;write_callback = write_callback;

    if ((err = soundio_outstream_open(outstream))) {
        fprintf(stderr, "unable to open device: %s", soundio_strerror(err));
        return 1;
    }

    if (outstream-&gt;layout_error)
        fprintf(stderr, "unable to set channel layout: %s\n", soundio_strerror(outstream-&gt;layout_error));

    if ((err = soundio_outstream_start(outstream))) {
        fprintf(stderr, "unable to start device: %s", soundio_strerror(err));
        return 1;
    }

    for (;;)
        soundio_wait_events(soundio);

    soundio_outstream_destroy(outstream);
    soundio_device_unref(device);
    soundio_destroy(soundio);
    return 0;
}</code></pre>

      <h2 id="releases">Releases</h2>
      <h2>1.0.0</h2>
      <h4>Source</h4>
      <p>
      <a href="/release/libsoundio-1.0.0.tar.gz">libsoundio-1.0.0.tar.gz</a>
      </p>
      <h4>Windows Binary</h4>
      <p>
      <a href="/release/libsoundio-1.0.0.zip">libsoundio-1.0.0.zip</a>
      </p>
      <h2>About</h2>
      <p>libsoundio is the audio backend for
      <a href="http://genesisdaw.org/">Genesis Digital Audio Workstation</a>.
      It is also the audio backend for
      <a href="http://groovebasin.com/">Groove Basin</a>.
      </p>
      <p>
      The primary developer of libsoundio is <a href="http://andrewkelley.me">Andrew Kelley</a>, who can be found on <a href="https://github.com/andrewrk/">GitHub</a>.
      Consider
      <a href="https://salt.bountysource.com/teams/gdaw">financially supporting the project</a>.
      </p>
    </div>
    <footer>
    </footer>
    <script src="highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>
